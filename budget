#!/bin/env python3

#todo: clean up code tagged: '#HACK'
#todo: figure out "self" in classes
#todo: add error handling system

# libraries
from datetime import date, timedelta
from os.path import expanduser

try:
    import readline
except ImportError:
    pass

class color:
    def text(color, string):
        colors = {"red": "\33[31m", "green": "\33[32m", "redbg": "\33[41m",
                  "greenbg": "\33[42m", "cend": "\33[0m"}
        colored_string = colors[color] + string + colors["cend"]

        return colored_string

class dateinfo:
    def today():
        date_today = date.today()
        year = date_today.strftime("%Y")
        month = date_today.strftime("%m")
        day = date_today.strftime("%d")

        return (year, month, day)

    def last_month():
        date_last_month = date.today().replace(day=1) - timedelta(days=1)
        year = date_last_month.strftime("%Y")
        month = date_last_month.strftime("%m")

        return (year, month)

    def to_string(year, month, day):
        date_str = "{}-{}-{}".format(year, month, day)

        return date_str

class budgets:
    path = expanduser("~/.budget_file")
    budget = []
    entry_dict = {"year": 0, "month": 1, "day": 2,
                  "amount": 3, "purpose": 4, "tag": 5}

    entry_format = "{year};{month};{day};{amount};{purpose};{tag}\n"

    def format_entry(year, month, day, amount, purpose, tag):
        amount = round(float(amount), 2)
        entry = (year, month, day, amount, purpose, tag)

        return entry

    def read_entry(entry, item):
        item_value = entry[budgets.entry_dict[item]]

        return item_value

    #HACK (from stackoverflow)
    def translate_entry(entry):
        temp_tuple_list = list(zip(budgets.entry_dict, entry))
        entry_as_dict = {k: v for k,v in temp_tuple_list}

        return entry_as_dict

    def filter(budget, year, month):
        filtered_budget = []

        for entry in budget:
            entry_year = budgets.read_entry(entry, "year")
            entry_month = budgets.read_entry(entry, "month")

            if entry_month == month and entry_month == month:
                filtered_budget.extend([entry])

        return filtered_budget

class budgetfile:
    def read(path):
        budget = []

        try:
            with open(path, "r") as budgetfile:
                for line in budgetfile:
                    line = line.strip("\n")
                    line = line.split(";")
                    bd = budgets.entry_dict

                    year = line[bd["year"]]
                    month = line[bd["month"]]
                    day = line[bd["day"]]
                    amount = float(line[bd["amount"]])
                    purpose = line[bd["purpose"]]
                    tag = line[bd["tag"]]

                    entry = budgets.format_entry(year, month, day,
                                                 amount, purpose, tag)

                    budget.extend([entry])

            return budget

        except FileNotFoundError:
            print(path + " not found.")
        except PermissionError:
            print("Permission denied: "+ path)

    def write(path, budget):
        entry_format = budgets.entry_format

        try:
            with open(path, "w") as budgetfile:
                for entry in budget:
                    entry_as_dict = budgets.translate_entry(entry)
                    entry_formatted = entry_format.format(**entry_as_dict)

                    budgetfile.write(entry_formatted)

        except PermissionError:
            print("Permission denied: "+ path)

    def backup(path):
        try:
            backup_file = path + ".edit"
            with open(path, "r") as org_budgetfile:
                with open(backup_file, "w") as bckp_budgetfile:
                    for entry in org_budgetfile:
                        bckp_budgetfile.write(entry)

        except FileNotFoundError:
            print(path + " not found.")
        except PermissionError:
            print("Permission denied: "+ path)

class transaction:
    def new(amount, purpose, tag='notag'):
        date = dateinfo.today()
        year = date[0]
        month = date[1]
        day = date[2]

        transaction = budgets.format_entry(year, month, day,
                                           amount, purpose, tag)

        return transaction

    def add(budget, transaction):
        budget = budget.extend([transaction])

        return budget

class calculate:
    def budget(budget):
        saldo = 0
        income = 0
        expenses = 0

        for entry in budget:
            amount = budgets.read_entry(entry, "amount")
            saldo += amount

            if amount > 0:
                income += amount
            else:
                expenses += amount

        saldo = round(saldo, 2)
        income = round(income, 2)
        expenses = round(expenses, 2)

        calculation = {"saldo": saldo, "income": income,
                       "expenses": expenses}

        return calculation

class visualize:
    def summary(budget_calculation):
        bc = budget_calculation
        saldo = str(bc["saldo"])
        income = color.text("green", str(bc["income"]))
        expenses = color.text("red", str(bc["expenses"]))
        vis_saldo = "Saldo: {} Income: {} Expenses: {}"
        vis_saldo = vis_saldo.format(saldo, income, expenses)

        return vis_saldo

class commands:
    def total():
        budget_calc = calculate.budget(budgets.budget)
        budget_vis = visualize.summary(budget_calc)

        print(budget_vis)

    def month():
        year = dateinfo.today()[0]
        month = dateinfo.today()[1]

        budget_monthly = budgets.filter(budgets.budget, year, month)
        budget_calc = calculate.budget(budget_monthly)
        budget_vis = visualize.summary(budget_calc)

        print(budget_vis)

    def transaction(args):
        print(args)
        amount = args[0]
        purpose = args[1]

        if len(args) >= 3:
            tag = args[2]
            transac = transaction.new(amount, purpose, tag)
        else:
            transac = transaction.new(amount, purpose)

        transaction.add(budgets.budget, transac)

    def raw_list():
        for entry in budgets.budget:
            print(entry)
    def help():
        print("Available commands:")
        for entry in available_commands.commands:
            print(entry)
    #HACK
    def exit():
        path = "/home/plensch/projects/budget/budget_file"
        budgetfile.write(path, budgets.budget)
        print("All changes have been saved.")
        raise SystemExit

class available_commands:
    commands = {"total": commands.total,
                "month": commands.month,
                "t": commands.transaction,
                "l": commands.raw_list,
                "h": commands.help,
                "q": commands.exit}

class userinput:
    def split(raw_in):
        in_list = raw_in.split(" ")
        command = in_list[0]
        arguments = in_list[1:]
        cmd_args = {"command": command, "arguments": arguments}

        return cmd_args

    def execute(userin):
        try:
            cmd = userin["command"]
            args = userin["arguments"]
            exec_func = available_commands.commands[cmd]

            if args and '' not in args:
                return exec_func(args)
            else:
                return exec_func()
        except:
            raise

if __name__ == "__main__":
    try:
        path = budgets.path
        budgets.budget = budgetfile.read(path)
        budgetfile.backup(path)

        prompt = "> "

        while True:
            try:
                userin = input(prompt)
                userin_split = userinput.split(userin)
                userinput.execute(userin_split)

            except KeyError:
                print(userin + " - Command not found.")
            except SystemExit:
                break

    except KeyboardInterrupt:
        print("\nAborted - No changes have been made.")
